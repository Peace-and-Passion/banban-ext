import {Currency} from '../types.ts';

/**
 * strip html <h3>hello</h3> -> hello
 *   base: https://stackoverflow.com/questions/5002111/how-to-strip-html-tags-from-string-in-javascript
 *
 * @param htmlStr - html string
 * @returns a stripped string
 */
export function stripHTML(htmlStr: string): string {
    return htmlStr.replace(/<\/?[^>]+(>|$)/g, "");
}


/**
 * decode HTML Entities
 *
 * @params text - input text
 * @returns decoded string
 *
 * @tests deno test -A  src/test/utils/utils_test.ts --filter test-decodeHtmlEntities
 */

export function decodeHtmlEntities(text: string): string {
    if (!text) return text;
    const htmlEntities: Record<string, string> = {
        '&quot;': '"',
        '&apos;': '\'',
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        // add another item here and below?
    };
    return text.replaceAll(/&quot;|&apos;|&amp;|&lt;|&gt;/g, match => htmlEntities[match]);
}


/**
 * simple detection : is html string or not
 */
export function isHTMLString(str: string): boolean {
    if (str?.includes("</")) return true;
    return false;
}

/**
 * unicode -> readable text
 *   e.g. \u8A73\u7D30\u3068\u30D5\u30A3\u30C3\u30C8\u611F
 *
 * @param str - unicode string
 * returns replaced string
 */
export function unescapeUnicode(str: string): string {
    return str.replace(/\\u[\dA-F]{4}/gi, function (match: any) {
        return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
    });
}


/**
 * GENERATED BY CHATGPT
 *
 * Escapes single and double quotes in a string for use in an XPath expression.
 *
 * This function handles strings containing both single (') and double (") quotes
 * by splitting the input string at these characters and using the concat() function
 * in XPath to correctly represent the string. This is necessary because XPath
 * does not have a built-in mechanism to escape quotes within string literals.
 *
 * @param {string} s - The string to be escaped for XPath.
 * @returns {string} An XPath expression using concat() that represents the input string.
 *
 * Usage Example:
 * let text = "Charlotte's \"the\" foobar's text";
 * let xpathExpr = xpathStringEscape(text);
 * // xpathExpr will be: concat('Charlotte', "'", 's ', '"', 'the', '"', ' foobar', "'", 's text')
 */
export function xpathStringEscape(s: string): string {
    let parts = [];
    let cur = [];
    for (let char of s) {
        if (char === "'" || char === '"') {
            if (cur.length > 0) {
                parts.push("'" + cur.join('') + "'");
                cur = [];
            }
            // Add the quote character as a separate part
            parts.push(char === "'" ? '"' + char + '"' : "'" + char + "'");
        } else {
            cur.push(char);
        }
    }

    // Add any remaining characters
    if (cur.length > 0) {
        parts.push("'" + cur.join('') + "'");
    }

    // Concatenate all parts using the concat function
    if (parts.length == 0) return s;// can't happen
    if (parts.length == 1) return "'" + s + "'"
    return 'concat(' + parts.join(', ') + ')';
}


/**
 * SearchParams number
 *   "https://foo.com/bar.jpg?good=morning&hello=world" == "https://foo.com/bar.jpg?hello=world&good=morning"
 *
 * @param url1 - url
 * @param url2 - url
 * @param ignoreParams ignore params: ['w', 'width', 'h', 'height']
 * @returns true for equal
 *
 * @tests deno test -A  src/test/utils/utils_test.ts --filter test-urlsAreEqual
 */
export function urlsAreEqual(url1: string, url2: string, ignoreParams?: string[]): boolean {
    const urlObj1: URL = new URL(url1);
    const urlObj2: URL = new URL(url2);

    if (urlObj1.pathname !== urlObj2.pathname || urlObj1.hostname !== urlObj2.hostname) {
        return false;
    }

    const params1: URLSearchParams = new URLSearchParams(urlObj1.search);
    const params2: URLSearchParams = new URLSearchParams(urlObj2.search);

    ignoreParams?.forEach((param: string) => {
        params1.delete(param);
        params2.delete(param);
    });

    if (Array.from(params1).length !== Array.from(params2).length) {
        return false;
    }

    for (let [key, value] of params1) {
        if (value !== params2.get(key)) {
            return false;
        }
    }

    return true;
}

/**
 * replace url param only if exists in the original url.
 *
 * @param url - The original URL where the parameter needs to be updated.
 * @param key - The key of the query parameter to be updated.
 * @param value - The new value for the query parameter.
 * @returns The updated URL if the key exists, otherwise the original URL.
 *
 * @tests deno test -A  src/test/utils/utils_test.ts --filter test-replaceURLParam
 */
export function replaceURLParam(url: string, key: string, value: string): string {
    const urlObj = new URL(url);

    if (urlObj.searchParams.has(key)) {
        urlObj.searchParams.set(key, value);
        return urlObj.toString();
    } else {
        return url;
    }
}

/**
 * Replace url to absolute
 *   <a href="/foo/bar"> -> <a href="https://abc.com/foo/bar>
 *   <img src="/img/foo.jpg"> -> <img src="https://abc.com/img/foo.jpg">
 *
 * @param domain - domain string e.g. www.amazon.com
 * @param htmlString - html string
 * @returns replaced HTML string
 *
 * @tests deno test -A  src/test/utils/utils_test.ts --filter test-replaceURLToAbsolute
 */
export function replaceURLToAbsolute(domainOrURL: string, htmlString: string): string {
    const domain: string = domainOrURL.includes("https://") ? new URL(domainOrURL).hostname : domainOrURL;
    if (!isHTMLString(htmlString)) return htmlString;
    const fullPathHead: string = '"https://' + domain + '/';
    const res1: string = htmlString.replaceAll('href="/', 'href=' + fullPathHead);
    return res1.replaceAll('src="/', 'src=' + fullPathHead);
}


/**
 * add target="_blank" to a tag.
 *   <a href="/foo/bar"> -> <a target="_blank" href="/foo/bar>
 *
 * @param htmlString - html string
 * @returns replaced HTML string
 *
 * @tests deno test -A  src/test/utils/utils_test.ts --filter test-addTargetBlankToHref
 */
export function addTargetBlankToHref(htmlString: string): string {
    if (!isHTMLString(htmlString)) return htmlString;
    return htmlString.replaceAll('href="', 'target="_blank" href="');
}



/**
 * replace: <ol> -> <ul>
 * @param htmlstring - <ol id="foo">...</ol>...
 * @returns replaced html string
 */
export function replaceOlWithUl(htmlString: string): string {
    if (!htmlString) return htmlString;
    return htmlString.replace(/<ol(\s+[^>]+)?>/g, '<ul$1>').replace(/<\/ol>/g, '</ul>');
}
